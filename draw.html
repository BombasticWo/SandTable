<!DOCTYPE html>
<html>
<head>
    <title>Draw & Convert to G-Code</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #f0f0f0;
        }

        h1 {
            margin-bottom: 20px;
        }

        canvas {
            border: 2px solid #333;
            background: white;
            cursor: crosshair;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
            margin-bottom: 20px;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .text-controls {
            border: 2px solid #9b59b6;
            border-radius: 5px;
            padding: 10px;
            background-color: #f5e6ff;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .text-controls label {
            font-weight: bold;
            color: #9b59b6;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #3498db;
            color: white;
        }

        button:hover {
            background-color: #2980b9;
        }

        #clearBtn {
            background-color: #e74c3c;
        }

        #clearBtn:hover {
            background-color: #c0392b;
        }

        #downloadBtn {
            background-color: #27ae60;
        }

        #downloadBtn:hover {
            background-color: #229954;
        }

        #backBtn {
            background-color: #95a5a6;
        }

        #backBtn:hover {
            background-color: #7f8c8d;
        }

        #gcodePreview {
            width: 400px;
            height: 200px;
            font-family: monospace;
            font-size: 12px;
            background: #1a252f;
            color: #1abc9c;
            border: 1px solid #34495e;
            padding: 10px;
            border-radius: 5px;
            overflow: auto;
        }

        #textInput {
            padding: 8px 12px;
            font-size: 14px;
            border: 1px solid #bdc3c7;
            border-radius: 5px;
            min-width: 150px;
        }

        #fontSizeInput {
            padding: 8px 12px;
            font-size: 14px;
            border: 1px solid #bdc3c7;
            border-radius: 5px;
            width: 80px;
        }

        #fontSelect {
            padding: 8px 12px;
            font-size: 14px;
            border: 1px solid #bdc3c7;
            border-radius: 5px;
        }

        #addTextBtn {
            background-color: #9b59b6;
        }

        #addTextBtn:hover {
            background-color: #8e44ad;
        }

        #deleteTextBtn {
            background-color: #e74c3c;
        }

        #deleteTextBtn:hover {
            background-color: #c0392b;
        }
    </style>
</head>
<body>
    <h1>Draw & Convert to G-Code</h1>
    <p style="color: #666; margin: 0 0 20px 0;">Sand Table: 180mm Ã— 180mm</p>
    
    <div class="controls">
        <button id="downloadBtn">Download G-Code</button>
        <button id="clearBtn">Clear Canvas</button>
        <button id="backBtn">Back to Menu</button>
    </div>

    <div class="text-controls">
        <label>Text Tools:</label>
        <input type="text" id="textInput" placeholder="Enter text to add">
        <select id="fontSelect">
            <option value="Arial" style="font-family: Arial;">Arial</option>
            <option value="Times New Roman" style="font-family: 'Times New Roman';">Times New Roman</option>
            <option value="Courier New" style="font-family: 'Courier New';">Courier New</option>
            <option value="Georgia" style="font-family: Georgia;">Georgia</option>
            <option value="Verdana" style="font-family: Verdana;">Verdana</option>
        </select>
        <input type="number" id="fontSizeInput" placeholder="Font size" value="16" min="8" max="72">
        <button id="addTextBtn">Add Text</button>
        <button id="deleteTextBtn">Delete Text</button>
    </div>

    <canvas id="drawingCanvas" width="500" height="500"></canvas>

    <h3>G-Code Preview:</h3>
    <textarea id="gcodePreview" readonly></textarea>

    <script>
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const downloadBtn = document.getElementById('downloadBtn');
        const clearBtn = document.getElementById('clearBtn');
        const backBtn = document.getElementById('backBtn');
        const addTextBtn = document.getElementById('addTextBtn');
        const deleteTextBtn = document.getElementById('deleteTextBtn');
        const textInput = document.getElementById('textInput');
        const fontSelect = document.getElementById('fontSelect');
        const fontSizeInput = document.getElementById('fontSizeInput');
        const gcodePreview = document.getElementById('gcodePreview');

        let isDrawing = false;
        let strokes = [];
        let currentStroke = [];
        let textElements = [];
        let isAddingText = false;
        let selectedTextIndex = -1;
        let draggingHandle = null;
        let draggingText = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let dragStartTextX = 0;
        let dragStartTextY = 0;

        // Initialize drawing
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseleave', stopDrawing);

        function startDrawing(event) {
            if (isAddingText) return; // Don't draw when adding text
            if (draggingText) return; // Don't draw when dragging text
            
            // Check if trying to drag resize handle
            if (selectedTextIndex >= 0) {
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                const textElem = textElements[selectedTextIndex];
                ctx.font = `bold ${textElem.fontSize}px Arial`;
                const metrics = ctx.measureText(textElem.text);
                const textWidth = metrics.width;
                const textHeight = textElem.fontSize;
                
                const handleSize = 8;
                const bottom = textElem.y + textHeight;
                const right = textElem.x + textWidth;
                
                // If clicking on resize handle or text, don't draw
                if ((x >= right - handleSize && x <= right + handleSize &&
                    y >= bottom - handleSize && y <= bottom + handleSize) ||
                    (x >= textElem.x && x <= textElem.x + textWidth &&
                     y >= textElem.y && y <= textElem.y + textHeight)) {
                    return;
                }
            }
            
            isDrawing = true;
            currentStroke = [];
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            currentStroke.push({ x, y });
            ctx.beginPath();
            ctx.moveTo(x, y);
        }

        function draw(event) {
            if (!isDrawing || draggingHandle) return;
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            currentStroke.push({ x, y });
            ctx.lineTo(x, y);
            ctx.stroke();
        }

        function stopDrawing() {
            if (isDrawing && currentStroke.length > 0) {
                strokes.push(currentStroke);
                isDrawing = false;
                updateGcodePreview();
            }
        }

        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Redraw strokes
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            for (let stroke of strokes) {
                if (stroke.length === 0) continue;
                ctx.beginPath();
                ctx.moveTo(stroke[0].x, stroke[0].y);
                for (let i = 1; i < stroke.length; i++) {
                    ctx.lineTo(stroke[i].x, stroke[i].y);
                }
                ctx.stroke();
            }
            
            // Redraw text
            ctx.fillStyle = '#000000';
            ctx.textBaseline = 'top';
            for (let i = 0; i < textElements.length; i++) {
                const textElem = textElements[i];
                ctx.font = `bold ${textElem.fontSize}px ${textElem.font}`;
                ctx.fillText(textElem.text, textElem.x, textElem.y);
                
                // Draw selection box if selected
                if (i === selectedTextIndex) {
                    const metrics = ctx.measureText(textElem.text);
                    const textWidth = metrics.width;
                    const textHeight = textElem.fontSize;
                    ctx.strokeStyle = '#3498db';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(textElem.x - 2, textElem.y - 2, textWidth + 4, textHeight + 4);
                    
                    // Draw resize handle
                    const handleSize = 8;
                    ctx.fillStyle = '#3498db';
                    ctx.fillRect(textElem.x + textWidth - 2 - handleSize/2, 
                                 textElem.y + textHeight - 2 - handleSize/2, 
                                 handleSize, handleSize);
                }
            }
        }

        clearBtn.addEventListener('click', () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            strokes = [];
            currentStroke = [];
            textElements = [];
            gcodePreview.value = '';
        });

        backBtn.addEventListener('click', () => {
            window.location.href = 'index.html';
        });

        addTextBtn.addEventListener('click', () => {
            if (textInput.value.trim() === '') {
                alert('Please enter text first!');
                return;
            }
            isAddingText = true;
            canvas.style.cursor = 'crosshair';
            canvas.title = 'Click to place text';
        });

        deleteTextBtn.addEventListener('click', () => {
            if (selectedTextIndex >= 0) {
                textElements.splice(selectedTextIndex, 1);
                selectedTextIndex = -1;
                redrawCanvas();
                updateGcodePreview();
            } else {
                alert('Please select text to delete!');
            }
        });

        canvas.addEventListener('click', (event) => {
            if (isAddingText) {
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                textElements.push({
                    text: textInput.value,
                    x: x,
                    y: y,
                    fontSize: parseInt(fontSizeInput.value),
                    font: fontSelect.value
                });
                redrawCanvas();
                textInput.value = '';
                isAddingText = false;
                canvas.style.cursor = 'crosshair';
                canvas.title = '';
                updateGcodePreview();
            } else {
                // Check if clicking on existing text
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                selectedTextIndex = -1;
                for (let i = 0; i < textElements.length; i++) {
                    const textElem = textElements[i];
                    ctx.font = `bold ${textElem.fontSize}px ${textElem.font}`;
                    const metrics = ctx.measureText(textElem.text);
                    const textWidth = metrics.width;
                    const textHeight = textElem.fontSize;
                    
                    if (x >= textElem.x && x <= textElem.x + textWidth &&
                        y >= textElem.y && y <= textElem.y + textHeight) {
                        selectedTextIndex = i;
                        fontSizeInput.value = textElem.fontSize;
                        fontSelect.value = textElem.font;
                        break;
                    }
                }
                redrawCanvas();
            }
        });

        canvas.addEventListener('mousedown', (event) => {
            if (selectedTextIndex >= 0) {
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                const textElem = textElements[selectedTextIndex];
                ctx.font = `bold ${textElem.fontSize}px ${textElem.font}`;
                const metrics = ctx.measureText(textElem.text);
                const textWidth = metrics.width;
                const textHeight = textElem.fontSize;
                
                const handleSize = 8;
                const bottom = textElem.y + textHeight;
                const right = textElem.x + textWidth;
                
                // Check if clicking on resize handle
                if (x >= right - handleSize && x <= right + handleSize &&
                    y >= bottom - handleSize && y <= bottom + handleSize) {
                    draggingHandle = 'bottom-right';
                    dragStartY = y;
                } 
                // Check if clicking on text to drag it
                else if (x >= textElem.x && x <= textElem.x + textWidth &&
                         y >= textElem.y && y <= textElem.y + textHeight) {
                    draggingText = true;
                    dragStartX = x;
                    dragStartY = y;
                    dragStartTextX = textElem.x;
                    dragStartTextY = textElem.y;
                }
            }
        });

        canvas.addEventListener('mousemove', (event) => {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            if (draggingText && selectedTextIndex >= 0) {
                const xDelta = x - dragStartX;
                const yDelta = y - dragStartY;
                textElements[selectedTextIndex].x = dragStartTextX + xDelta;
                textElements[selectedTextIndex].y = dragStartTextY + yDelta;
                redrawCanvas();
                updateGcodePreview();
            } else if (selectedTextIndex >= 0) {
                const textElem = textElements[selectedTextIndex];
                ctx.font = `bold ${textElem.fontSize}px ${textElem.font}`;
                const metrics = ctx.measureText(textElem.text);
                const textWidth = metrics.width;
                const textHeight = textElem.fontSize;
                
                const handleSize = 8;
                const bottom = textElem.y + textHeight;
                const right = textElem.x + textWidth;
                
                // Check if hovering over resize handle
                if (x >= right - handleSize && x <= right + handleSize &&
                    y >= bottom - handleSize && y <= bottom + handleSize) {
                    canvas.style.cursor = 'se-resize';
                } else if (x >= textElem.x && x <= textElem.x + textWidth &&
                           y >= textElem.y && y <= textElem.y + textHeight) {
                    canvas.style.cursor = 'move';
                } else {
                    canvas.style.cursor = 'default';
                }
            }
            
            if (draggingHandle === 'bottom-right') {
                const yDelta = y - dragStartY;
                const newSize = Math.max(8, textElements[selectedTextIndex].fontSize + yDelta);
                textElements[selectedTextIndex].fontSize = newSize;
                dragStartY = y;
                redrawCanvas();
                updateGcodePreview();
            }
        });

        canvas.addEventListener('mouseup', () => {
            draggingHandle = null;
            draggingText = false;
        });

        canvas.addEventListener('mouseleave', () => {
            draggingHandle = null;
            draggingText = false;
        });

        downloadBtn.addEventListener('click', downloadGCode);

        function convertToGCode() {
            let gcode = [];
            gcode.push('G90'); // Absolute positioning
            gcode.push('G21'); // Millimeters

            // 180x180mm sand table
            // Canvas is 500x500 pixels, scale to fit 180x180mm
            const tableSize = 180; // mm
            const canvasSize = 500; // pixels
            const scale = tableSize / canvasSize; // 0.36 mm per pixel
            const offsetX = 0;
            const offsetY = 0;

            // Add drawing strokes
            for (let stroke of strokes) {
                if (stroke.length === 0) continue;

                // Move to first point
                let x = stroke[0].x * scale + offsetX;
                let y = stroke[0].y * scale + offsetY;
                gcode.push(`G0 X${x.toFixed(2)} Y${y.toFixed(2)}`);

                // Draw line segments
                for (let i = 1; i < stroke.length; i++) {
                    x = stroke[i].x * scale + offsetX;
                    y = stroke[i].y * scale + offsetY;
                    gcode.push(`G1 X${x.toFixed(2)} Y${y.toFixed(2)} F1000`);
                }
            }

            // Add text elements as comments in G-code
            for (let textElem of textElements) {
                const x = textElem.x * scale + offsetX;
                const y = textElem.y * scale + offsetY;
                gcode.push(`; Text: "${textElem.text}" at X${x.toFixed(2)} Y${y.toFixed(2)} (${textElem.font}, ${textElem.fontSize}px)`);
            }

            gcode.push('G0 X0 Y0'); // Return to origin
            gcode.push('M30'); // End of program

            return gcode.join('\n');
        }

        function updateGcodePreview() {
            const gcode = convertToGCode();
            gcodePreview.value = gcode;
        }

        function downloadGCode() {
            if (strokes.length === 0) {
                alert('Please draw something first!');
                return;
            }

            const gcode = convertToGCode();
            const element = document.createElement('a');
            element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(gcode));
            element.setAttribute('download', 'drawing.gcode');
            element.style.display = 'none';
            document.body.appendChild(element);
            element.click();
            document.body.removeChild(element);
        }
    </script>
</body>
</html>
